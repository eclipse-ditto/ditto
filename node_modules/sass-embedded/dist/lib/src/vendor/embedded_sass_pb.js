"use strict";
// Copyright 2019 Google Inc. Use of this source code is governed by an
// MIT-style license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodePackageImporter = exports.Value_Calculation_CalculationOperation = exports.Value_Calculation_CalculationValue = exports.Value_Calculation = exports.Value_ArgumentList = exports.Value_CompilerMixin = exports.Value_HostFunction = exports.Value_CompilerFunction = exports.Value_Map_Entry = exports.Value_Map = exports.Value_List = exports.Value_HwbColor = exports.Value_HslColor = exports.Value_RgbColor = exports.Value_Number = exports.Value_String = exports.Value = exports.SourceSpan_SourceLocation = exports.SourceSpan = exports.ProtocolError = exports.OutboundMessage_FunctionCallRequest = exports.OutboundMessage_FileImportRequest = exports.OutboundMessage_ImportRequest = exports.OutboundMessage_CanonicalizeRequest = exports.OutboundMessage_LogEvent = exports.OutboundMessage_CompileResponse_CompileFailure = exports.OutboundMessage_CompileResponse_CompileSuccess = exports.OutboundMessage_CompileResponse = exports.OutboundMessage_VersionResponse = exports.OutboundMessage = exports.InboundMessage_FunctionCallResponse = exports.InboundMessage_FileImportResponse = exports.InboundMessage_ImportResponse_ImportSuccess = exports.InboundMessage_ImportResponse = exports.InboundMessage_CanonicalizeResponse = exports.InboundMessage_CompileRequest_Importer = exports.InboundMessage_CompileRequest_StringInput = exports.InboundMessage_CompileRequest = exports.InboundMessage_VersionRequest = exports.InboundMessage = exports.CalculationOperator = exports.SingletonValue = exports.ListSeparator = exports.ProtocolErrorType = exports.LogEventType = exports.Syntax = exports.OutputStyle = void 0;
const protobuf_1 = require("@bufbuild/protobuf");
/**
 * Possible ways to format the CSS output. The compiler is not required to
 * support all possible options; if the host requests an unsupported style, the
 * compiler should choose the closest supported style.
 *
 * @generated from enum sass.embedded_protocol.OutputStyle
 */
var OutputStyle;
(function (OutputStyle) {
    /**
     * Each selector and declaration is written on its own line.
     *
     * @generated from enum value: EXPANDED = 0;
     */
    OutputStyle[OutputStyle["EXPANDED"] = 0] = "EXPANDED";
    /**
     * The entire stylesheet is written on a single line, with as few characters
     * as possible.
     *
     * @generated from enum value: COMPRESSED = 1;
     */
    OutputStyle[OutputStyle["COMPRESSED"] = 1] = "COMPRESSED";
})(OutputStyle || (exports.OutputStyle = OutputStyle = {}));
// Retrieve enum metadata with: proto3.getEnumType(OutputStyle)
protobuf_1.proto3.util.setEnumType(OutputStyle, "sass.embedded_protocol.OutputStyle", [
    { no: 0, name: "EXPANDED" },
    { no: 1, name: "COMPRESSED" },
]);
/**
 * Possible syntaxes for a Sass stylesheet.
 *
 * @generated from enum sass.embedded_protocol.Syntax
 */
var Syntax;
(function (Syntax) {
    /**
     * The CSS-superset `.scss` syntax.
     *
     * @generated from enum value: SCSS = 0;
     */
    Syntax[Syntax["SCSS"] = 0] = "SCSS";
    /**
     * The indented `.sass` syntax.
     *
     * @generated from enum value: INDENTED = 1;
     */
    Syntax[Syntax["INDENTED"] = 1] = "INDENTED";
    /**
     * Plain CSS syntax that doesn't support any special Sass features.
     *
     * @generated from enum value: CSS = 2;
     */
    Syntax[Syntax["CSS"] = 2] = "CSS";
})(Syntax || (exports.Syntax = Syntax = {}));
// Retrieve enum metadata with: proto3.getEnumType(Syntax)
protobuf_1.proto3.util.setEnumType(Syntax, "sass.embedded_protocol.Syntax", [
    { no: 0, name: "SCSS" },
    { no: 1, name: "INDENTED" },
    { no: 2, name: "CSS" },
]);
/**
 * The possible types of [LogEvent].
 *
 * @generated from enum sass.embedded_protocol.LogEventType
 */
var LogEventType;
(function (LogEventType) {
    /**
     * A warning for something other than a deprecated Sass feature. Often emitted
     * due to a stylesheet using the `@warn` rule.
     *
     * @generated from enum value: WARNING = 0;
     */
    LogEventType[LogEventType["WARNING"] = 0] = "WARNING";
    /**
     * A warning indicating that the stylesheet is using a deprecated Sass
     * feature. Compilers should not add text like "deprecation warning" to
     * deprecation warnings; it's up to the host to determine how to signal that
     * to the user.
     *
     * @generated from enum value: DEPRECATION_WARNING = 1;
     */
    LogEventType[LogEventType["DEPRECATION_WARNING"] = 1] = "DEPRECATION_WARNING";
    /**
     * A message generated by the user for their own debugging purposes.
     *
     * @generated from enum value: DEBUG = 2;
     */
    LogEventType[LogEventType["DEBUG"] = 2] = "DEBUG";
})(LogEventType || (exports.LogEventType = LogEventType = {}));
// Retrieve enum metadata with: proto3.getEnumType(LogEventType)
protobuf_1.proto3.util.setEnumType(LogEventType, "sass.embedded_protocol.LogEventType", [
    { no: 0, name: "WARNING" },
    { no: 1, name: "DEPRECATION_WARNING" },
    { no: 2, name: "DEBUG" },
]);
/**
 * Potential types of protocol errors.
 *
 * @generated from enum sass.embedded_protocol.ProtocolErrorType
 */
var ProtocolErrorType;
(function (ProtocolErrorType) {
    /**
     * A message was received that couldn't be decoded as an `InboundMessage` (for
     * the compiler) or `OutboundMessage` (for the host).
     *
     * @generated from enum value: PARSE = 0;
     */
    ProtocolErrorType[ProtocolErrorType["PARSE"] = 0] = "PARSE";
    /**
     * A message was received that violated a documented restriction, such as not
     * providing a mandatory field.
     *
     * @generated from enum value: PARAMS = 1;
     */
    ProtocolErrorType[ProtocolErrorType["PARAMS"] = 1] = "PARAMS";
    /**
     * Something unexpected went wrong within the endpoint.
     *
     * @generated from enum value: INTERNAL = 2;
     */
    ProtocolErrorType[ProtocolErrorType["INTERNAL"] = 2] = "INTERNAL";
})(ProtocolErrorType || (exports.ProtocolErrorType = ProtocolErrorType = {}));
// Retrieve enum metadata with: proto3.getEnumType(ProtocolErrorType)
protobuf_1.proto3.util.setEnumType(ProtocolErrorType, "sass.embedded_protocol.ProtocolErrorType", [
    { no: 0, name: "PARSE" },
    { no: 1, name: "PARAMS" },
    { no: 2, name: "INTERNAL" },
]);
/**
 * Different types of separators a list can have.
 *
 * @generated from enum sass.embedded_protocol.ListSeparator
 */
var ListSeparator;
(function (ListSeparator) {
    /**
     * List elements are separated by a comma.
     *
     * @generated from enum value: COMMA = 0;
     */
    ListSeparator[ListSeparator["COMMA"] = 0] = "COMMA";
    /**
     * List elements are separated by whitespace.
     *
     * @generated from enum value: SPACE = 1;
     */
    ListSeparator[ListSeparator["SPACE"] = 1] = "SPACE";
    /**
     * List elements are separated by a forward slash.
     *
     * @generated from enum value: SLASH = 2;
     */
    ListSeparator[ListSeparator["SLASH"] = 2] = "SLASH";
    /**
     * The list's separator hasn't yet been determined. This is only allowed for
     * singleton and empty lists.
     *
     * Singleton lists and empty lists don't have separators defined. This means
     * that list functions will prefer other lists' separators if possible.
     *
     * @generated from enum value: UNDECIDED = 3;
     */
    ListSeparator[ListSeparator["UNDECIDED"] = 3] = "UNDECIDED";
})(ListSeparator || (exports.ListSeparator = ListSeparator = {}));
// Retrieve enum metadata with: proto3.getEnumType(ListSeparator)
protobuf_1.proto3.util.setEnumType(ListSeparator, "sass.embedded_protocol.ListSeparator", [
    { no: 0, name: "COMMA" },
    { no: 1, name: "SPACE" },
    { no: 2, name: "SLASH" },
    { no: 3, name: "UNDECIDED" },
]);
/**
 * Singleton SassScript values that have no internal state.
 *
 * @generated from enum sass.embedded_protocol.SingletonValue
 */
var SingletonValue;
(function (SingletonValue) {
    /**
     * The SassScript boolean true value.
     *
     * @generated from enum value: TRUE = 0;
     */
    SingletonValue[SingletonValue["TRUE"] = 0] = "TRUE";
    /**
     * The SassScript boolean false value.
     *
     * @generated from enum value: FALSE = 1;
     */
    SingletonValue[SingletonValue["FALSE"] = 1] = "FALSE";
    /**
     * The SassScript null value.
     *
     * @generated from enum value: NULL = 2;
     */
    SingletonValue[SingletonValue["NULL"] = 2] = "NULL";
})(SingletonValue || (exports.SingletonValue = SingletonValue = {}));
// Retrieve enum metadata with: proto3.getEnumType(SingletonValue)
protobuf_1.proto3.util.setEnumType(SingletonValue, "sass.embedded_protocol.SingletonValue", [
    { no: 0, name: "TRUE" },
    { no: 1, name: "FALSE" },
    { no: 2, name: "NULL" },
]);
/**
 * An operator used in a calculation value's operation.
 *
 * @generated from enum sass.embedded_protocol.CalculationOperator
 */
var CalculationOperator;
(function (CalculationOperator) {
    /**
     * The addition operator.
     *
     * @generated from enum value: PLUS = 0;
     */
    CalculationOperator[CalculationOperator["PLUS"] = 0] = "PLUS";
    /**
     * The subtraction operator.
     *
     * @generated from enum value: MINUS = 1;
     */
    CalculationOperator[CalculationOperator["MINUS"] = 1] = "MINUS";
    /**
     * The multiplication operator.
     *
     * @generated from enum value: TIMES = 2;
     */
    CalculationOperator[CalculationOperator["TIMES"] = 2] = "TIMES";
    /**
     * The division operator.
     *
     * @generated from enum value: DIVIDE = 3;
     */
    CalculationOperator[CalculationOperator["DIVIDE"] = 3] = "DIVIDE";
})(CalculationOperator || (exports.CalculationOperator = CalculationOperator = {}));
// Retrieve enum metadata with: proto3.getEnumType(CalculationOperator)
protobuf_1.proto3.util.setEnumType(CalculationOperator, "sass.embedded_protocol.CalculationOperator", [
    { no: 0, name: "PLUS" },
    { no: 1, name: "MINUS" },
    { no: 2, name: "TIMES" },
    { no: 3, name: "DIVIDE" },
]);
/**
 * The wrapper type for all messages sent from the host to the compiler. This
 * provides a `oneof` that makes it possible to determine the type of each
 * inbound message.
 *
 * @generated from message sass.embedded_protocol.InboundMessage
 */
class InboundMessage extends protobuf_1.Message {
    constructor(data) {
        super();
        /**
         * The wrapped message. Mandatory.
         *
         * @generated from oneof sass.embedded_protocol.InboundMessage.message
         */
        this.message = { case: undefined };
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new InboundMessage().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new InboundMessage().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new InboundMessage().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(InboundMessage, a, b);
    }
}
exports.InboundMessage = InboundMessage;
InboundMessage.runtime = protobuf_1.proto3;
InboundMessage.typeName = "sass.embedded_protocol.InboundMessage";
InboundMessage.fields = protobuf_1.proto3.util.newFieldList(() => [
    { no: 2, name: "compile_request", kind: "message", T: InboundMessage_CompileRequest, oneof: "message" },
    { no: 3, name: "canonicalize_response", kind: "message", T: InboundMessage_CanonicalizeResponse, oneof: "message" },
    { no: 4, name: "import_response", kind: "message", T: InboundMessage_ImportResponse, oneof: "message" },
    { no: 5, name: "file_import_response", kind: "message", T: InboundMessage_FileImportResponse, oneof: "message" },
    { no: 6, name: "function_call_response", kind: "message", T: InboundMessage_FunctionCallResponse, oneof: "message" },
    { no: 7, name: "version_request", kind: "message", T: InboundMessage_VersionRequest, oneof: "message" },
]);
/**
 * A request for information about the version of the embedded compiler. The
 * host can use this to provide diagnostic information to the user, to check
 * which features the compiler supports, or to ensure that it's compatible
 * with the same protocol version the compiler supports.
 *
 * @generated from message sass.embedded_protocol.InboundMessage.VersionRequest
 */
class InboundMessage_VersionRequest extends protobuf_1.Message {
    constructor(data) {
        super();
        /**
         * This version request's id.
         *
         * @generated from field: uint32 id = 1;
         */
        this.id = 0;
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new InboundMessage_VersionRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new InboundMessage_VersionRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new InboundMessage_VersionRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(InboundMessage_VersionRequest, a, b);
    }
}
exports.InboundMessage_VersionRequest = InboundMessage_VersionRequest;
InboundMessage_VersionRequest.runtime = protobuf_1.proto3;
InboundMessage_VersionRequest.typeName = "sass.embedded_protocol.InboundMessage.VersionRequest";
InboundMessage_VersionRequest.fields = protobuf_1.proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
]);
/**
 * A request that compiles an entrypoint to CSS.
 *
 * @generated from message sass.embedded_protocol.InboundMessage.CompileRequest
 */
class InboundMessage_CompileRequest extends protobuf_1.Message {
    constructor(data) {
        super();
        /**
         * The input stylesheet to parse. Mandatory.
         *
         * @generated from oneof sass.embedded_protocol.InboundMessage.CompileRequest.input
         */
        this.input = { case: undefined };
        /**
         * How to format the CSS output.
         *
         * @generated from field: sass.embedded_protocol.OutputStyle style = 4;
         */
        this.style = OutputStyle.EXPANDED;
        /**
         * Whether to generate a source map. Note that this will *not* add a source
         * map comment to the stylesheet; that's up to the host or its users.
         *
         * @generated from field: bool source_map = 5;
         */
        this.sourceMap = false;
        /**
         * Importers (including load paths on the filesystem) to use when resolving
         * imports that can't be resolved relative to the file that contains it. Each
         * importer is checked in order until one recognizes the imported URL.
         *
         * @generated from field: repeated sass.embedded_protocol.InboundMessage.CompileRequest.Importer importers = 6;
         */
        this.importers = [];
        /**
         * Signatures for custom global functions whose behavior is defined by the
         * host.
         *
         * If this is not a valid Sass function signature that could appear after
         * `@function` in a Sass stylesheet (such as `mix($color1, $color2, $weight:
         * 50%)`), or if it conflicts with a function name that's built into the
         * Sass language, the compiler must treat the compilation as failed.
         *
         * Compilers must ensure that pure-Sass functions take precedence over
         * custom global functions.
         *
         * @generated from field: repeated string global_functions = 7;
         */
        this.globalFunctions = [];
        /**
         * Whether to use terminal colors in the formatted message of errors and
         * logs.
         *
         * @generated from field: bool alert_color = 8;
         */
        this.alertColor = false;
        /**
         * Whether to encode the formatted message of errors and logs in ASCII.
         *
         * @generated from field: bool alert_ascii = 9;
         */
        this.alertAscii = false;
        /**
         * Whether to report all deprecation warnings or only the first few ones.
         * If this is `false`, the compiler may choose not to send events for
         * repeated deprecation warnings. If this is `true`, the compiler must emit
         * an event for every deprecation warning it encounters.
         *
         * @generated from field: bool verbose = 10;
         */
        this.verbose = false;
        /**
         * Whether to omit events for deprecation warnings coming from dependencies
         * (files loaded from a different importer than the input).
         *
         * @generated from field: bool quiet_deps = 11;
         */
        this.quietDeps = false;
        /**
         * Whether to include sources in the generated sourcemap
         *
         * @generated from field: bool source_map_include_sources = 12;
         */
        this.sourceMapIncludeSources = false;
        /**
         * Whether to emit a `@charset`/BOM for non-ASCII stylesheets.
         *
         * @generated from field: bool charset = 13;
         */
        this.charset = false;
        /**
         * Whether to silently suppresses all `LogEvent`s.
         *
         * @generated from field: bool silent = 14;
         */
        this.silent = false;
        /**
         * Deprecation IDs or versions to treat as fatal.
         *
         * @generated from field: repeated string fatal_deprecation = 15;
         */
        this.fatalDeprecation = [];
        /**
         * Deprecation IDs to ignore.
         *
         * @generated from field: repeated string silence_deprecation = 16;
         */
        this.silenceDeprecation = [];
        /**
         * Deprecation IDs to opt into early.
         *
         * @generated from field: repeated string future_deprecation = 17;
         */
        this.futureDeprecation = [];
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new InboundMessage_CompileRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new InboundMessage_CompileRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new InboundMessage_CompileRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(InboundMessage_CompileRequest, a, b);
    }
}
exports.InboundMessage_CompileRequest = InboundMessage_CompileRequest;
InboundMessage_CompileRequest.runtime = protobuf_1.proto3;
InboundMessage_CompileRequest.typeName = "sass.embedded_protocol.InboundMessage.CompileRequest";
InboundMessage_CompileRequest.fields = protobuf_1.proto3.util.newFieldList(() => [
    { no: 2, name: "string", kind: "message", T: InboundMessage_CompileRequest_StringInput, oneof: "input" },
    { no: 3, name: "path", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "input" },
    { no: 4, name: "style", kind: "enum", T: protobuf_1.proto3.getEnumType(OutputStyle) },
    { no: 5, name: "source_map", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "importers", kind: "message", T: InboundMessage_CompileRequest_Importer, repeated: true },
    { no: 7, name: "global_functions", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 8, name: "alert_color", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 9, name: "alert_ascii", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "verbose", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 11, name: "quiet_deps", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 12, name: "source_map_include_sources", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 13, name: "charset", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 14, name: "silent", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 15, name: "fatal_deprecation", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 16, name: "silence_deprecation", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 17, name: "future_deprecation", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
]);
/**
 * An input stylesheet provided as plain text, rather than loaded from the
 * filesystem.
 *
 * @generated from message sass.embedded_protocol.InboundMessage.CompileRequest.StringInput
 */
class InboundMessage_CompileRequest_StringInput extends protobuf_1.Message {
    constructor(data) {
        super();
        /**
         * The contents of the stylesheet.
         *
         * @generated from field: string source = 1;
         */
        this.source = "";
        /**
         * The location from which `source` was loaded. If this is empty, it
         * indicates that the URL is unknown.
         *
         * This must be a canonical URL recognized by `importer`, if it's passed.
         *
         * @generated from field: string url = 2;
         */
        this.url = "";
        /**
         * The syntax to use to parse `source`.
         *
         * @generated from field: sass.embedded_protocol.Syntax syntax = 3;
         */
        this.syntax = Syntax.SCSS;
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new InboundMessage_CompileRequest_StringInput().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new InboundMessage_CompileRequest_StringInput().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new InboundMessage_CompileRequest_StringInput().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(InboundMessage_CompileRequest_StringInput, a, b);
    }
}
exports.InboundMessage_CompileRequest_StringInput = InboundMessage_CompileRequest_StringInput;
InboundMessage_CompileRequest_StringInput.runtime = protobuf_1.proto3;
InboundMessage_CompileRequest_StringInput.typeName = "sass.embedded_protocol.InboundMessage.CompileRequest.StringInput";
InboundMessage_CompileRequest_StringInput.fields = protobuf_1.proto3.util.newFieldList(() => [
    { no: 1, name: "source", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "syntax", kind: "enum", T: protobuf_1.proto3.getEnumType(Syntax) },
    { no: 4, name: "importer", kind: "message", T: InboundMessage_CompileRequest_Importer },
]);
/**
 * A wrapper message that represents either a user-defined importer or a
 * load path on disk. This must be a wrapper because `oneof` types can't be
 * `repeated`.
 *
 * @generated from message sass.embedded_protocol.InboundMessage.CompileRequest.Importer
 */
class InboundMessage_CompileRequest_Importer extends protobuf_1.Message {
    constructor(data) {
        super();
        /**
         * The possible types of importer. Mandatory.
         *
         * @generated from oneof sass.embedded_protocol.InboundMessage.CompileRequest.Importer.importer
         */
        this.importer = { case: undefined };
        /**
         * The set of URL schemes that are considered *non-canonical* for this
         * importer. This must be empty unless `importer.importer_id` is set.
         *
         * If any element of this contains a character other than a lowercase
         * ASCII letter, an ASCII numeral, U+002B (`+`), U+002D (`-`), or U+002E
         * (`.`), the compiler must treat the compilation as failed.
         *
         * @generated from field: repeated string non_canonical_scheme = 4;
         */
        this.nonCanonicalScheme = [];
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new InboundMessage_CompileRequest_Importer().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new InboundMessage_CompileRequest_Importer().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new InboundMessage_CompileRequest_Importer().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(InboundMessage_CompileRequest_Importer, a, b);
    }
}
exports.InboundMessage_CompileRequest_Importer = InboundMessage_CompileRequest_Importer;
InboundMessage_CompileRequest_Importer.runtime = protobuf_1.proto3;
InboundMessage_CompileRequest_Importer.typeName = "sass.embedded_protocol.InboundMessage.CompileRequest.Importer";
InboundMessage_CompileRequest_Importer.fields = protobuf_1.proto3.util.newFieldList(() => [
    { no: 1, name: "path", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "importer" },
    { no: 2, name: "importer_id", kind: "scalar", T: 13 /* ScalarType.UINT32 */, oneof: "importer" },
    { no: 3, name: "file_importer_id", kind: "scalar", T: 13 /* ScalarType.UINT32 */, oneof: "importer" },
    { no: 5, name: "node_package_importer", kind: "message", T: NodePackageImporter, oneof: "importer" },
    { no: 4, name: "non_canonical_scheme", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
]);
/**
 * A response indicating the result of canonicalizing an imported URL.
 *
 * @generated from message sass.embedded_protocol.InboundMessage.CanonicalizeResponse
 */
class InboundMessage_CanonicalizeResponse extends protobuf_1.Message {
    constructor(data) {
        super();
        /**
         * @generated from field: uint32 id = 1;
         */
        this.id = 0;
        /**
         * The result of canonicalization. If this is unset, it indicates that the
         * importer either did not recognize the URL, or could not find a stylesheet
         * at the location it referred to. Optional.
         *
         * @generated from oneof sass.embedded_protocol.InboundMessage.CanonicalizeResponse.result
         */
        this.result = { case: undefined };
        /**
         * Whether `containing_url` in `CanonicalizeRequest` is unused.
         *
         * The compiler can cache the `CanonicalizeResponse` if the `containing_url`
         * is unused.
         *
         * The default value is `false`, thus when the value is not set by the host,
         * the `CanonicalizeResponse` will not be cached by the compiler.
         *
         * @generated from field: bool containing_url_unused = 4;
         */
        this.containingUrlUnused = false;
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new InboundMessage_CanonicalizeResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new InboundMessage_CanonicalizeResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new InboundMessage_CanonicalizeResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(InboundMessage_CanonicalizeResponse, a, b);
    }
}
exports.InboundMessage_CanonicalizeResponse = InboundMessage_CanonicalizeResponse;
InboundMessage_CanonicalizeResponse.runtime = protobuf_1.proto3;
InboundMessage_CanonicalizeResponse.typeName = "sass.embedded_protocol.InboundMessage.CanonicalizeResponse";
InboundMessage_CanonicalizeResponse.fields = protobuf_1.proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "result" },
    { no: 3, name: "error", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "result" },
    { no: 4, name: "containing_url_unused", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
]);
/**
 * A response indicating the result of importing a canonical URL.
 *
 * @generated from message sass.embedded_protocol.InboundMessage.ImportResponse
 */
class InboundMessage_ImportResponse extends protobuf_1.Message {
    constructor(data) {
        super();
        /**
         * @generated from field: uint32 id = 1;
         */
        this.id = 0;
        /**
         * The result of loading the URL. If this is unset, it indicates that the
         * importer either did not recognize the URL, or could not find a stylesheet
         * at the location it referred to. Optional.
         *
         * @generated from oneof sass.embedded_protocol.InboundMessage.ImportResponse.result
         */
        this.result = { case: undefined };
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new InboundMessage_ImportResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new InboundMessage_ImportResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new InboundMessage_ImportResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(InboundMessage_ImportResponse, a, b);
    }
}
exports.InboundMessage_ImportResponse = InboundMessage_ImportResponse;
InboundMessage_ImportResponse.runtime = protobuf_1.proto3;
InboundMessage_ImportResponse.typeName = "sass.embedded_protocol.InboundMessage.ImportResponse";
InboundMessage_ImportResponse.fields = protobuf_1.proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "success", kind: "message", T: InboundMessage_ImportResponse_ImportSuccess, oneof: "result" },
    { no: 3, name: "error", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "result" },
]);
/**
 * The stylesheet's contents were loaded successfully.
 *
 * @generated from message sass.embedded_protocol.InboundMessage.ImportResponse.ImportSuccess
 */
class InboundMessage_ImportResponse_ImportSuccess extends protobuf_1.Message {
    constructor(data) {
        super();
        /**
         * The text of the stylesheet.
         *
         * @generated from field: string contents = 1;
         */
        this.contents = "";
        /**
         * The syntax of `contents`.
         *
         * @generated from field: sass.embedded_protocol.Syntax syntax = 2;
         */
        this.syntax = Syntax.SCSS;
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new InboundMessage_ImportResponse_ImportSuccess().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new InboundMessage_ImportResponse_ImportSuccess().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new InboundMessage_ImportResponse_ImportSuccess().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(InboundMessage_ImportResponse_ImportSuccess, a, b);
    }
}
exports.InboundMessage_ImportResponse_ImportSuccess = InboundMessage_ImportResponse_ImportSuccess;
InboundMessage_ImportResponse_ImportSuccess.runtime = protobuf_1.proto3;
InboundMessage_ImportResponse_ImportSuccess.typeName = "sass.embedded_protocol.InboundMessage.ImportResponse.ImportSuccess";
InboundMessage_ImportResponse_ImportSuccess.fields = protobuf_1.proto3.util.newFieldList(() => [
    { no: 1, name: "contents", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "syntax", kind: "enum", T: protobuf_1.proto3.getEnumType(Syntax) },
    { no: 3, name: "source_map_url", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
]);
/**
 * A response indicating the result of redirecting a URL to the filesystem.
 *
 * @generated from message sass.embedded_protocol.InboundMessage.FileImportResponse
 */
class InboundMessage_FileImportResponse extends protobuf_1.Message {
    constructor(data) {
        super();
        /**
         * @generated from field: uint32 id = 1;
         */
        this.id = 0;
        /**
         * The result of loading the URL. An unset result indicates that the
         * importer did not recognize the URL and other importers or load paths
         * should be tried. Optional.
         *
         * @generated from oneof sass.embedded_protocol.InboundMessage.FileImportResponse.result
         */
        this.result = { case: undefined };
        /**
         * Whether `containing_url` in `FileImportRequest` is unused.
         *
         * The compiler can cache the `FileImportResponse` if the `containing_url`
         * is unused.
         *
         * The default value is `false`, thus when the value is not set by the host,
         * the `FileImportResponse` will not be cached by the compiler.
         *
         * @generated from field: bool containing_url_unused = 4;
         */
        this.containingUrlUnused = false;
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new InboundMessage_FileImportResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new InboundMessage_FileImportResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new InboundMessage_FileImportResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(InboundMessage_FileImportResponse, a, b);
    }
}
exports.InboundMessage_FileImportResponse = InboundMessage_FileImportResponse;
InboundMessage_FileImportResponse.runtime = protobuf_1.proto3;
InboundMessage_FileImportResponse.typeName = "sass.embedded_protocol.InboundMessage.FileImportResponse";
InboundMessage_FileImportResponse.fields = protobuf_1.proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "file_url", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "result" },
    { no: 3, name: "error", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "result" },
    { no: 4, name: "containing_url_unused", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
]);
/**
 * A response indicating the result of calling a custom Sass function defined
 * in the host.
 *
 * @generated from message sass.embedded_protocol.InboundMessage.FunctionCallResponse
 */
class InboundMessage_FunctionCallResponse extends protobuf_1.Message {
    constructor(data) {
        super();
        /**
         * @generated from field: uint32 id = 1;
         */
        this.id = 0;
        /**
         * The result of calling the function. Mandatory.
         *
         * @generated from oneof sass.embedded_protocol.InboundMessage.FunctionCallResponse.result
         */
        this.result = { case: undefined };
        /**
         * The IDs of all `Value.ArgumentList`s in `FunctionCallRequest.arguments`
         * whose keywords were accessed. See `Value.ArgumentList` for details. This
         * may not include the special value `0` and it may not include multiple
         * instances of the same ID.
         *
         * @generated from field: repeated uint32 accessed_argument_lists = 4;
         */
        this.accessedArgumentLists = [];
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new InboundMessage_FunctionCallResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new InboundMessage_FunctionCallResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new InboundMessage_FunctionCallResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(InboundMessage_FunctionCallResponse, a, b);
    }
}
exports.InboundMessage_FunctionCallResponse = InboundMessage_FunctionCallResponse;
InboundMessage_FunctionCallResponse.runtime = protobuf_1.proto3;
InboundMessage_FunctionCallResponse.typeName = "sass.embedded_protocol.InboundMessage.FunctionCallResponse";
InboundMessage_FunctionCallResponse.fields = protobuf_1.proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "success", kind: "message", T: Value, oneof: "result" },
    { no: 3, name: "error", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "result" },
    { no: 4, name: "accessed_argument_lists", kind: "scalar", T: 13 /* ScalarType.UINT32 */, repeated: true },
]);
/**
 * The wrapper type for all messages sent from the compiler to the host. This
 * provides a `oneof` that makes it possible to determine the type of each
 * outbound message.
 *
 * @generated from message sass.embedded_protocol.OutboundMessage
 */
class OutboundMessage extends protobuf_1.Message {
    constructor(data) {
        super();
        /**
         * The wrapped message. Mandatory.
         *
         * @generated from oneof sass.embedded_protocol.OutboundMessage.message
         */
        this.message = { case: undefined };
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new OutboundMessage().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new OutboundMessage().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new OutboundMessage().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(OutboundMessage, a, b);
    }
}
exports.OutboundMessage = OutboundMessage;
OutboundMessage.runtime = protobuf_1.proto3;
OutboundMessage.typeName = "sass.embedded_protocol.OutboundMessage";
OutboundMessage.fields = protobuf_1.proto3.util.newFieldList(() => [
    { no: 1, name: "error", kind: "message", T: ProtocolError, oneof: "message" },
    { no: 2, name: "compile_response", kind: "message", T: OutboundMessage_CompileResponse, oneof: "message" },
    { no: 3, name: "log_event", kind: "message", T: OutboundMessage_LogEvent, oneof: "message" },
    { no: 4, name: "canonicalize_request", kind: "message", T: OutboundMessage_CanonicalizeRequest, oneof: "message" },
    { no: 5, name: "import_request", kind: "message", T: OutboundMessage_ImportRequest, oneof: "message" },
    { no: 6, name: "file_import_request", kind: "message", T: OutboundMessage_FileImportRequest, oneof: "message" },
    { no: 7, name: "function_call_request", kind: "message", T: OutboundMessage_FunctionCallRequest, oneof: "message" },
    { no: 8, name: "version_response", kind: "message", T: OutboundMessage_VersionResponse, oneof: "message" },
]);
/**
 * A response that contains the version of the embedded compiler.
 *
 * @generated from message sass.embedded_protocol.OutboundMessage.VersionResponse
 */
class OutboundMessage_VersionResponse extends protobuf_1.Message {
    constructor(data) {
        super();
        /**
         * This version request's id.
         *
         * @generated from field: uint32 id = 5;
         */
        this.id = 0;
        /**
         * The version of the embedded protocol, in semver format.
         *
         * @generated from field: string protocol_version = 1;
         */
        this.protocolVersion = "";
        /**
         * The version of the embedded compiler package. This has no guaranteed
         * format, although compilers are encouraged to use semver.
         *
         * @generated from field: string compiler_version = 2;
         */
        this.compilerVersion = "";
        /**
         * The version of the Sass implementation that the embedded compiler wraps.
         * This has no guaranteed format, although Sass implementations are
         * encouraged to use semver.
         *
         * @generated from field: string implementation_version = 3;
         */
        this.implementationVersion = "";
        /**
         * The name of the Sass implementation that the embedded compiler wraps.
         *
         * @generated from field: string implementation_name = 4;
         */
        this.implementationName = "";
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new OutboundMessage_VersionResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new OutboundMessage_VersionResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new OutboundMessage_VersionResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(OutboundMessage_VersionResponse, a, b);
    }
}
exports.OutboundMessage_VersionResponse = OutboundMessage_VersionResponse;
OutboundMessage_VersionResponse.runtime = protobuf_1.proto3;
OutboundMessage_VersionResponse.typeName = "sass.embedded_protocol.OutboundMessage.VersionResponse";
OutboundMessage_VersionResponse.fields = protobuf_1.proto3.util.newFieldList(() => [
    { no: 5, name: "id", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 1, name: "protocol_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "compiler_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "implementation_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "implementation_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * A response that contains the result of a compilation.
 *
 * @generated from message sass.embedded_protocol.OutboundMessage.CompileResponse
 */
class OutboundMessage_CompileResponse extends protobuf_1.Message {
    constructor(data) {
        super();
        /**
         * The success or failure result of the compilation. Mandatory.
         *
         * @generated from oneof sass.embedded_protocol.OutboundMessage.CompileResponse.result
         */
        this.result = { case: undefined };
        /**
         * The canonical URLs of all source files loaded during the compilation.
         *
         * The compiler must ensure that each canonical URL appears only once in
         * this list. This must include the entrypoint file's URL if either
         * `CompileRequest.input.path` or `CompileRequest.StringInput.url` was
         * passed.
         *
         * @generated from field: repeated string loaded_urls = 4;
         */
        this.loadedUrls = [];
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new OutboundMessage_CompileResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new OutboundMessage_CompileResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new OutboundMessage_CompileResponse().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(OutboundMessage_CompileResponse, a, b);
    }
}
exports.OutboundMessage_CompileResponse = OutboundMessage_CompileResponse;
OutboundMessage_CompileResponse.runtime = protobuf_1.proto3;
OutboundMessage_CompileResponse.typeName = "sass.embedded_protocol.OutboundMessage.CompileResponse";
OutboundMessage_CompileResponse.fields = protobuf_1.proto3.util.newFieldList(() => [
    { no: 2, name: "success", kind: "message", T: OutboundMessage_CompileResponse_CompileSuccess, oneof: "result" },
    { no: 3, name: "failure", kind: "message", T: OutboundMessage_CompileResponse_CompileFailure, oneof: "result" },
    { no: 4, name: "loaded_urls", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
]);
/**
 * A message indicating that the Sass file was successfully compiled to CSS.
 *
 * @generated from message sass.embedded_protocol.OutboundMessage.CompileResponse.CompileSuccess
 */
class OutboundMessage_CompileResponse_CompileSuccess extends protobuf_1.Message {
    constructor(data) {
        super();
        /**
         * The compiled CSS.
         *
         * @generated from field: string css = 1;
         */
        this.css = "";
        /**
         * The JSON-encoded source map, or the empty string if
         * `CompileRequest.source_map` was `false`.
         *
         * The compiler must not add a `"file"` key to this source map. It's the
         * host's (or the host's user's) responsibility to determine how the
         * generated CSS can be reached from the source map.
         *
         * @generated from field: string source_map = 2;
         */
        this.sourceMap = "";
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new OutboundMessage_CompileResponse_CompileSuccess().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new OutboundMessage_CompileResponse_CompileSuccess().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new OutboundMessage_CompileResponse_CompileSuccess().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(OutboundMessage_CompileResponse_CompileSuccess, a, b);
    }
}
exports.OutboundMessage_CompileResponse_CompileSuccess = OutboundMessage_CompileResponse_CompileSuccess;
OutboundMessage_CompileResponse_CompileSuccess.runtime = protobuf_1.proto3;
OutboundMessage_CompileResponse_CompileSuccess.typeName = "sass.embedded_protocol.OutboundMessage.CompileResponse.CompileSuccess";
OutboundMessage_CompileResponse_CompileSuccess.fields = protobuf_1.proto3.util.newFieldList(() => [
    { no: 1, name: "css", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "source_map", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * A message indicating that the Sass file could not be successfully
 * compiled to CSS.
 *
 * @generated from message sass.embedded_protocol.OutboundMessage.CompileResponse.CompileFailure
 */
class OutboundMessage_CompileResponse_CompileFailure extends protobuf_1.Message {
    constructor(data) {
        super();
        /**
         * A message describing the reason for the failure.
         *
         * @generated from field: string message = 1;
         */
        this.message = "";
        /**
         * The stack trace associated with the failure.
         *
         * The empty string indicates that no stack trace is available. Otherwise,
         * the format of this stack trace is not specified and is likely to be
         * inconsistent between implementations.
         *
         * @generated from field: string stack_trace = 3;
         */
        this.stackTrace = "";
        /**
         * A formatted, human-readable string that contains the message, span
         * (if available), and trace (if available). The format of this string is
         * not specified and is likely to be inconsistent between implementations.
         *
         * @generated from field: string formatted = 4;
         */
        this.formatted = "";
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new OutboundMessage_CompileResponse_CompileFailure().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new OutboundMessage_CompileResponse_CompileFailure().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new OutboundMessage_CompileResponse_CompileFailure().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(OutboundMessage_CompileResponse_CompileFailure, a, b);
    }
}
exports.OutboundMessage_CompileResponse_CompileFailure = OutboundMessage_CompileResponse_CompileFailure;
OutboundMessage_CompileResponse_CompileFailure.runtime = protobuf_1.proto3;
OutboundMessage_CompileResponse_CompileFailure.typeName = "sass.embedded_protocol.OutboundMessage.CompileResponse.CompileFailure";
OutboundMessage_CompileResponse_CompileFailure.fields = protobuf_1.proto3.util.newFieldList(() => [
    { no: 1, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "span", kind: "message", T: SourceSpan },
    { no: 3, name: "stack_trace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "formatted", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * An event indicating that a message should be displayed to the user.
 *
 * @generated from message sass.embedded_protocol.OutboundMessage.LogEvent
 */
class OutboundMessage_LogEvent extends protobuf_1.Message {
    constructor(data) {
        super();
        /**
         * @generated from field: sass.embedded_protocol.LogEventType type = 2;
         */
        this.type = LogEventType.WARNING;
        /**
         * The text of the message.
         *
         * @generated from field: string message = 3;
         */
        this.message = "";
        /**
         * The stack trace associated with this message.
         *
         * The empty string indicates that no stack trace is available. Otherwise,
         * the format of this stack trace is not specified and is likely to be
         * inconsistent between implementations.
         *
         * @generated from field: string stack_trace = 5;
         */
        this.stackTrace = "";
        /**
         * A formatted, human-readable string that contains the message, span (if
         * available), and trace (if available). The format of this string is not
         * specified and is likely to be inconsistent between implementations.
         *
         * @generated from field: string formatted = 6;
         */
        this.formatted = "";
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new OutboundMessage_LogEvent().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new OutboundMessage_LogEvent().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new OutboundMessage_LogEvent().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(OutboundMessage_LogEvent, a, b);
    }
}
exports.OutboundMessage_LogEvent = OutboundMessage_LogEvent;
OutboundMessage_LogEvent.runtime = protobuf_1.proto3;
OutboundMessage_LogEvent.typeName = "sass.embedded_protocol.OutboundMessage.LogEvent";
OutboundMessage_LogEvent.fields = protobuf_1.proto3.util.newFieldList(() => [
    { no: 2, name: "type", kind: "enum", T: protobuf_1.proto3.getEnumType(LogEventType) },
    { no: 3, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "span", kind: "message", T: SourceSpan, opt: true },
    { no: 5, name: "stack_trace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "formatted", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "deprecation_type", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
]);
/**
 * A request for a custom importer to convert an imported URL to its canonical
 * format.
 *
 * If the URL is not recognized by this importer, or if no stylesheet is found
 * at that URL, `CanonicalizeResponse.result` must be `null`. Otherwise, the
 * importer must return an absolute URL, including a scheme.
 *
 * > The host's documentation should encourage the use of file importers (via
 * > `CompileRequest.Importer.file_importer_id`, `FileImportRequest`, and
 * > `FileImportResponse`) for any importers that simply refer to files on
 * > disk. This will allow Sass to handle the logic of resolving partials,
 * > file extensions, and index files.
 *
 * If Sass has already loaded a stylesheet with the returned canonical URL, it
 * re-uses the existing parse tree. This means that importers must ensure that
 * the same canonical URL always refers to the same stylesheet, *even across
 * different importers*. Importers must also ensure that any canonicalized
 * URLs they return can be passed back to `CanonicalizeRequest` and will be
 * returned unchanged.
 *
 * If this importer's URL format supports file extensions, it should
 * canonicalize them the same way as the default filesystem importer:
 *
 * * The importer should look for stylesheets by adding the prefix `_` to the
 *   URL's basename, and by adding the extensions `.sass` and `.scss` if the
 *   URL doesn't already have one of those extensions. For example, if the URL
 *   was `foo/bar/baz`, the importer would look for:
 *
 *   * `foo/bar/baz.sass`
 *   * `foo/bar/baz.scss`
 *   * `foo/bar/_baz.sass`
 *   * `foo/bar/_baz.scss`
 *
 *   If the URL was foo/bar/baz.scss, the importer would just look for:
 *
 *   * `foo/bar/baz.scss`
 *   * `foo/bar/_baz.scss`
 *
 *   If the importer finds a stylesheet at more than one of these URLs, it
 *   should respond with a `CanonicalizeResponse.result.error` indicating that
 *   the import is ambiguous. Note that if the extension is explicitly
 *   specified, a stylesheet with another extension may exist without error.
 *
 * * If none of the possible paths is valid, the importer should perform the
 *   same resolution on the URL followed by `/index`. In the example above, it
 *   would look for:
 *
 *   * `foo/bar/baz/_index.sass`
 *   * `foo/bar/baz/index.sass`
 *   * `foo/bar/baz/_index.scss`
 *   * `foo/bar/baz/index.scss`
 *
 *   As above, if the importer finds a stylesheet at more than one of these
 *   URLs, it should respond with a `CanonicalizeResponse.result.error`
 *   indicating that the import is ambiguous.
 *
 * @generated from message sass.embedded_protocol.OutboundMessage.CanonicalizeRequest
 */
class OutboundMessage_CanonicalizeRequest extends protobuf_1.Message {
    constructor(data) {
        super();
        /**
         * @generated from field: uint32 id = 1;
         */
        this.id = 0;
        /**
         * The unique ID of the importer being invoked. This must match an importer
         * ID passed to this compilation in `CompileRequest.importers` or
         * `CompileRequest.input.string.importer`.
         *
         * @generated from field: uint32 importer_id = 3;
         */
        this.importerId = 0;
        /**
         * The URL of the import to be canonicalized. This may be either absolute or
         * relative.
         *
         * When loading a URL, the compiler must first try resolving that URL
         * relative to the canonical URL of the current file, and canonicalizing the
         * result using the importer that loaded the current file. If this returns
         * `null`, the compiler must then try canonicalizing the original URL with
         * each importer in order until one returns something other than `null`.
         * That is the result of the import.
         *
         * @generated from field: string url = 4;
         */
        this.url = "";
        /**
         * Whether this request comes from an `@import` rule.
         *
         * When evaluating `@import` rules, URLs should canonicalize to an
         * [import-only file] if one exists for the URL being canonicalized.
         * Otherwise, canonicalization should be identical for `@import` and `@use`
         * rules.
         *
         * [import-only file]: https://sass-lang.com/documentation/at-rules/import#import-only-files
         *
         * @generated from field: bool from_import = 5;
         */
        this.fromImport = false;
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new OutboundMessage_CanonicalizeRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new OutboundMessage_CanonicalizeRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new OutboundMessage_CanonicalizeRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(OutboundMessage_CanonicalizeRequest, a, b);
    }
}
exports.OutboundMessage_CanonicalizeRequest = OutboundMessage_CanonicalizeRequest;
OutboundMessage_CanonicalizeRequest.runtime = protobuf_1.proto3;
OutboundMessage_CanonicalizeRequest.typeName = "sass.embedded_protocol.OutboundMessage.CanonicalizeRequest";
OutboundMessage_CanonicalizeRequest.fields = protobuf_1.proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "importer_id", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 4, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "from_import", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "containing_url", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
]);
/**
 * A request for a custom importer to load the contents of a stylesheet.
 *
 * @generated from message sass.embedded_protocol.OutboundMessage.ImportRequest
 */
class OutboundMessage_ImportRequest extends protobuf_1.Message {
    constructor(data) {
        super();
        /**
         * @generated from field: uint32 id = 1;
         */
        this.id = 0;
        /**
         * The unique ID of the importer being invoked. This must match an
         * `Importer.importer_id` passed to this compilation in
         * `CompileRequest.importers` or `CompileRequest.input.string.importer`.
         *
         * @generated from field: uint32 importer_id = 3;
         */
        this.importerId = 0;
        /**
         * The canonical URL of the import. This is guaranteed to be a URL returned
         * by a `CanonicalizeRequest` to this importer.
         *
         * @generated from field: string url = 4;
         */
        this.url = "";
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new OutboundMessage_ImportRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new OutboundMessage_ImportRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new OutboundMessage_ImportRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(OutboundMessage_ImportRequest, a, b);
    }
}
exports.OutboundMessage_ImportRequest = OutboundMessage_ImportRequest;
OutboundMessage_ImportRequest.runtime = protobuf_1.proto3;
OutboundMessage_ImportRequest.typeName = "sass.embedded_protocol.OutboundMessage.ImportRequest";
OutboundMessage_ImportRequest.fields = protobuf_1.proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "importer_id", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 4, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * A request for a custom filesystem importer to load the contents of a
 * stylesheet.
 *
 * A filesystem importer is represented in the compiler as an [importer]. When
 * the importer is invoked with a string `string`:
 *
 * [importer]: https://github.com/sass/sass/tree/main/spec/modules.md#importer
 *
 * * If `string` is an absolute URL whose scheme is `file`:
 *
 *   * Let `url` be string.
 *
 * * Otherwise:
 *
 *   * Let `fromImport` be `true` if the importer is being run for an
 *     `@import` and `false` otherwise.
 *
 *   * Let `containingUrl` be the canonical URL of the [current source file]
 *     if it has one, or undefined otherwise.
 *
 *
 *   * Let `response` be the result of sending a `FileImportRequest` with
 *     `string` as its `url`, `fromImport` as `from_import`, and
 *     `containingUrl` as `containing_url`.
 *
 *   * If `response.result` is null, return null.
 *
 *   * Otherwise, if `response.result.error` is set, throw an error.
 *
 *   * Otherwise, let `url` be `response.result.file_url`.
 *
 * * Let `resolved` be the result of [resolving `url`].
 *
 * * If `resolved` is null, return null.
 *
 * * Let `text` be the contents of the file at `resolved`.
 *
 * * Let `syntax` be:
 *   * "scss" if `url` ends in `.scss`.
 *   * "indented" if `url` ends in `.sass`.
 *   * "css" if `url` ends in `.css`.
 *
 *   > The algorithm for resolving a `file:` URL guarantees that `url` will have
 *   > one of these extensions.
 *
 * * Return `text`, `syntax`, and `resolved`.
 *
 * [current source file]: ../spec.md#current-source-file
 * [resolving `url`]: https://github.com/sass/sass/tree/main/spec/modules.md#resolving-a-file-url
 *
 * @generated from message sass.embedded_protocol.OutboundMessage.FileImportRequest
 */
class OutboundMessage_FileImportRequest extends protobuf_1.Message {
    constructor(data) {
        super();
        /**
         * @generated from field: uint32 id = 1;
         */
        this.id = 0;
        /**
         * The unique ID of the importer being invoked. This must match an
         * `Importer.file_importer_id` passed to this compilation in
         * `CompileRequest.importers` or `CompileRequest.input.string.importer`.
         *
         * @generated from field: uint32 importer_id = 3;
         */
        this.importerId = 0;
        /**
         * The (non-canonicalized) URL of the import.
         *
         * @generated from field: string url = 4;
         */
        this.url = "";
        /**
         * Whether this request comes from an `@import` rule.
         *
         * When evaluating `@import` rules, filesystem importers should load an
         * [import-only file] if one exists for the URL being canonicalized.
         * Otherwise, canonicalization should be identical for `@import` and `@use`
         * rules.
         *
         * [import-only file]: https://sass-lang.com/documentation/at-rules/import#import-only-files
         *
         * @generated from field: bool from_import = 5;
         */
        this.fromImport = false;
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new OutboundMessage_FileImportRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new OutboundMessage_FileImportRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new OutboundMessage_FileImportRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(OutboundMessage_FileImportRequest, a, b);
    }
}
exports.OutboundMessage_FileImportRequest = OutboundMessage_FileImportRequest;
OutboundMessage_FileImportRequest.runtime = protobuf_1.proto3;
OutboundMessage_FileImportRequest.typeName = "sass.embedded_protocol.OutboundMessage.FileImportRequest";
OutboundMessage_FileImportRequest.fields = protobuf_1.proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "importer_id", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 4, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "from_import", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "containing_url", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
]);
/**
 * A request to invoke a custom Sass function and return its result.
 *
 * @generated from message sass.embedded_protocol.OutboundMessage.FunctionCallRequest
 */
class OutboundMessage_FunctionCallRequest extends protobuf_1.Message {
    constructor(data) {
        super();
        /**
         * @generated from field: uint32 id = 1;
         */
        this.id = 0;
        /**
         * An identifier that indicates which function to invoke. Mandatory.
         *
         * @generated from oneof sass.embedded_protocol.OutboundMessage.FunctionCallRequest.identifier
         */
        this.identifier = { case: undefined };
        /**
         * The arguments passed to the function, in the order they appear in the
         * function signature passed to `CompileRequest.global_functions`.
         *
         * The compiler must ensure that a valid number of arguments are passed for
         * the given signature, that default argument values are instantiated
         * appropriately, and that variable argument lists (`$args...`) are passed
         * as `Value.ArgumentList`s.
         *
         * @generated from field: repeated sass.embedded_protocol.Value arguments = 5;
         */
        this.arguments = [];
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new OutboundMessage_FunctionCallRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new OutboundMessage_FunctionCallRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new OutboundMessage_FunctionCallRequest().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(OutboundMessage_FunctionCallRequest, a, b);
    }
}
exports.OutboundMessage_FunctionCallRequest = OutboundMessage_FunctionCallRequest;
OutboundMessage_FunctionCallRequest.runtime = protobuf_1.proto3;
OutboundMessage_FunctionCallRequest.typeName = "sass.embedded_protocol.OutboundMessage.FunctionCallRequest";
OutboundMessage_FunctionCallRequest.fields = protobuf_1.proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "identifier" },
    { no: 4, name: "function_id", kind: "scalar", T: 13 /* ScalarType.UINT32 */, oneof: "identifier" },
    { no: 5, name: "arguments", kind: "message", T: Value, repeated: true },
]);
/**
 * An error reported when an endpoint violates the embedded Sass protocol.
 *
 * @generated from message sass.embedded_protocol.ProtocolError
 */
class ProtocolError extends protobuf_1.Message {
    constructor(data) {
        super();
        /**
         * @generated from field: sass.embedded_protocol.ProtocolErrorType type = 1;
         */
        this.type = ProtocolErrorType.PARSE;
        /**
         * The ID of the request that had an error. This MUST be `4294967295` if the
         * request ID couldn't be determined, or if the error is being reported for a
         * response or an event.
         *
         * @generated from field: uint32 id = 2;
         */
        this.id = 0;
        /**
         * A human-readable message providing more detail about the error.
         *
         * @generated from field: string message = 3;
         */
        this.message = "";
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new ProtocolError().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new ProtocolError().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new ProtocolError().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(ProtocolError, a, b);
    }
}
exports.ProtocolError = ProtocolError;
ProtocolError.runtime = protobuf_1.proto3;
ProtocolError.typeName = "sass.embedded_protocol.ProtocolError";
ProtocolError.fields = protobuf_1.proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: protobuf_1.proto3.getEnumType(ProtocolErrorType) },
    { no: 2, name: "id", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * A chunk of a source file.
 *
 * @generated from message sass.embedded_protocol.SourceSpan
 */
class SourceSpan extends protobuf_1.Message {
    constructor(data) {
        super();
        /**
         * The text covered by the source span. Compilers must guarantee that this is
         * the text between `start.offset` and `end.offset` in the source file
         * referred to by `url`.
         *
         * @generated from field: string text = 1;
         */
        this.text = "";
        /**
         * The URL of the file to which this span refers.
         *
         * This may be empty, indicating that the span refers to a
         * `CompileRequest.StringInput` file that doesn't specify a URL.
         *
         * @generated from field: string url = 4;
         */
        this.url = "";
        /**
         * Additional source text surrounding this span.
         *
         * If this isn't empty, it must contain `text`. Furthermore, `text` must begin
         * at column `start.column` of a line in `context`.
         *
         * This usually contains the full lines the span begins and ends on if the
         * span itself doesn't cover the full lines.
         *
         * @generated from field: string context = 5;
         */
        this.context = "";
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new SourceSpan().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new SourceSpan().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new SourceSpan().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(SourceSpan, a, b);
    }
}
exports.SourceSpan = SourceSpan;
SourceSpan.runtime = protobuf_1.proto3;
SourceSpan.typeName = "sass.embedded_protocol.SourceSpan";
SourceSpan.fields = protobuf_1.proto3.util.newFieldList(() => [
    { no: 1, name: "text", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "start", kind: "message", T: SourceSpan_SourceLocation },
    { no: 3, name: "end", kind: "message", T: SourceSpan_SourceLocation, opt: true },
    { no: 4, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "context", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * A single point in a source file.
 *
 * @generated from message sass.embedded_protocol.SourceSpan.SourceLocation
 */
class SourceSpan_SourceLocation extends protobuf_1.Message {
    constructor(data) {
        super();
        /**
         * The 0-based offset of this location within the source file.
         *
         * @generated from field: uint32 offset = 1;
         */
        this.offset = 0;
        /**
         * The 0-based line number of this location within the source file.
         *
         * @generated from field: uint32 line = 2;
         */
        this.line = 0;
        /**
         * The 0-based column number of this location within its line.
         *
         * @generated from field: uint32 column = 3;
         */
        this.column = 0;
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new SourceSpan_SourceLocation().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new SourceSpan_SourceLocation().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new SourceSpan_SourceLocation().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(SourceSpan_SourceLocation, a, b);
    }
}
exports.SourceSpan_SourceLocation = SourceSpan_SourceLocation;
SourceSpan_SourceLocation.runtime = protobuf_1.proto3;
SourceSpan_SourceLocation.typeName = "sass.embedded_protocol.SourceSpan.SourceLocation";
SourceSpan_SourceLocation.fields = protobuf_1.proto3.util.newFieldList(() => [
    { no: 1, name: "offset", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "line", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "column", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
]);
/**
 * A SassScript value, passed to and returned by functions.
 *
 * @generated from message sass.embedded_protocol.Value
 */
class Value extends protobuf_1.Message {
    constructor(data) {
        super();
        /**
         * The value itself. Mandatory.
         *
         * This is wrapped in a message type rather than used directly to reduce
         * repetition, and because oneofs can't be repeated.
         *
         * @generated from oneof sass.embedded_protocol.Value.value
         */
        this.value = { case: undefined };
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Value().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Value().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Value().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(Value, a, b);
    }
}
exports.Value = Value;
Value.runtime = protobuf_1.proto3;
Value.typeName = "sass.embedded_protocol.Value";
Value.fields = protobuf_1.proto3.util.newFieldList(() => [
    { no: 1, name: "string", kind: "message", T: Value_String, oneof: "value" },
    { no: 2, name: "number", kind: "message", T: Value_Number, oneof: "value" },
    { no: 3, name: "rgb_color", kind: "message", T: Value_RgbColor, oneof: "value" },
    { no: 4, name: "hsl_color", kind: "message", T: Value_HslColor, oneof: "value" },
    { no: 5, name: "list", kind: "message", T: Value_List, oneof: "value" },
    { no: 6, name: "map", kind: "message", T: Value_Map, oneof: "value" },
    { no: 7, name: "singleton", kind: "enum", T: protobuf_1.proto3.getEnumType(SingletonValue), oneof: "value" },
    { no: 8, name: "compiler_function", kind: "message", T: Value_CompilerFunction, oneof: "value" },
    { no: 9, name: "host_function", kind: "message", T: Value_HostFunction, oneof: "value" },
    { no: 10, name: "argument_list", kind: "message", T: Value_ArgumentList, oneof: "value" },
    { no: 11, name: "hwb_color", kind: "message", T: Value_HwbColor, oneof: "value" },
    { no: 12, name: "calculation", kind: "message", T: Value_Calculation, oneof: "value" },
    { no: 13, name: "compiler_mixin", kind: "message", T: Value_CompilerMixin, oneof: "value" },
]);
/**
 * A SassScript string value.
 *
 * @generated from message sass.embedded_protocol.Value.String
 */
class Value_String extends protobuf_1.Message {
    constructor(data) {
        super();
        /**
         * The contents of the string.
         *
         * @generated from field: string text = 1;
         */
        this.text = "";
        /**
         * Whether the string is quoted or unquoted.
         *
         * @generated from field: bool quoted = 2;
         */
        this.quoted = false;
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Value_String().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Value_String().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Value_String().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(Value_String, a, b);
    }
}
exports.Value_String = Value_String;
Value_String.runtime = protobuf_1.proto3;
Value_String.typeName = "sass.embedded_protocol.Value.String";
Value_String.fields = protobuf_1.proto3.util.newFieldList(() => [
    { no: 1, name: "text", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "quoted", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
]);
/**
 * A SassScript number value.
 *
 * @generated from message sass.embedded_protocol.Value.Number
 */
class Value_Number extends protobuf_1.Message {
    constructor(data) {
        super();
        /**
         * The number's numeric value.
         *
         * @generated from field: double value = 1;
         */
        this.value = 0;
        /**
         * The number's numerator units.
         *
         * The endpoint sending the number must ensure that no numerator units are
         * [compatible][] with any denominator units. Such compatible units must be
         * simplified away according to the multiplicative factor between them
         * defined in the CSS Values and Units spec.
         *
         * [compatible]: https://www.w3.org/TR/css-values-4/#compat
         *
         * @generated from field: repeated string numerators = 2;
         */
        this.numerators = [];
        /**
         * The number's denominator units.
         *
         * @generated from field: repeated string denominators = 3;
         */
        this.denominators = [];
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Value_Number().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Value_Number().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Value_Number().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(Value_Number, a, b);
    }
}
exports.Value_Number = Value_Number;
Value_Number.runtime = protobuf_1.proto3;
Value_Number.typeName = "sass.embedded_protocol.Value.Number";
Value_Number.fields = protobuf_1.proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 2, name: "numerators", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "denominators", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
]);
/**
 * A SassScript color value, represented as red, green, and blue channels.
 *
 * All Sass color values can be equivalently represented as `RgbColor`,
 * `HslColor`, and `HwbColor` messages without loss of color information that
 * can affect CSS rendering. As such, either endpoint may choose to send any
 * color value as any one of these three messages.
 *
 * @generated from message sass.embedded_protocol.Value.RgbColor
 */
class Value_RgbColor extends protobuf_1.Message {
    constructor(data) {
        super();
        /**
         * The color's red channel. May not be above 255.
         *
         * @generated from field: uint32 red = 1;
         */
        this.red = 0;
        /**
         * The color's green channel. May not be above 255.
         *
         * @generated from field: uint32 green = 2;
         */
        this.green = 0;
        /**
         * The color's blue channel. May not be above 255.
         *
         * @generated from field: uint32 blue = 3;
         */
        this.blue = 0;
        /**
         * The color's alpha channel. Must be between 0 and 1,
         * inclusive.
         *
         * @generated from field: double alpha = 4;
         */
        this.alpha = 0;
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Value_RgbColor().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Value_RgbColor().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Value_RgbColor().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(Value_RgbColor, a, b);
    }
}
exports.Value_RgbColor = Value_RgbColor;
Value_RgbColor.runtime = protobuf_1.proto3;
Value_RgbColor.typeName = "sass.embedded_protocol.Value.RgbColor";
Value_RgbColor.fields = protobuf_1.proto3.util.newFieldList(() => [
    { no: 1, name: "red", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "green", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "blue", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 4, name: "alpha", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
]);
/**
 * A SassScript color value, represented as hue, saturation, and lightness channels.
 *
 * @generated from message sass.embedded_protocol.Value.HslColor
 */
class Value_HslColor extends protobuf_1.Message {
    constructor(data) {
        super();
        /**
         * The color's hue.
         *
         * @generated from field: double hue = 1;
         */
        this.hue = 0;
        /**
         * The color's percent saturation. Must be between 0 and 100,
         * inclusive.
         *
         * @generated from field: double saturation = 2;
         */
        this.saturation = 0;
        /**
         * The color's percent lightness. Must be between 0 and 100,
         * inclusive.
         *
         * @generated from field: double lightness = 3;
         */
        this.lightness = 0;
        /**
         * The color's alpha channel. Must be between 0 and 1,
         * inclusive.
         *
         * @generated from field: double alpha = 4;
         */
        this.alpha = 0;
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Value_HslColor().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Value_HslColor().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Value_HslColor().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(Value_HslColor, a, b);
    }
}
exports.Value_HslColor = Value_HslColor;
Value_HslColor.runtime = protobuf_1.proto3;
Value_HslColor.typeName = "sass.embedded_protocol.Value.HslColor";
Value_HslColor.fields = protobuf_1.proto3.util.newFieldList(() => [
    { no: 1, name: "hue", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 2, name: "saturation", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "lightness", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 4, name: "alpha", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
]);
/**
 * A SassScript color value, represented as hue, whiteness, and blackness
 * channels.
 *
 * @generated from message sass.embedded_protocol.Value.HwbColor
 */
class Value_HwbColor extends protobuf_1.Message {
    constructor(data) {
        super();
        /**
         * The color's hue.
         *
         * @generated from field: double hue = 1;
         */
        this.hue = 0;
        /**
         * The color's percent whiteness. Must be between 0 and 100,
         * inclusive. The sum of `whiteness` and `blackness` must not exceed 100.
         *
         * @generated from field: double whiteness = 2;
         */
        this.whiteness = 0;
        /**
         * The color's percent blackness. Must be between 0 and 100,
         * inclusive. The sum of `whiteness` and `blackness` must not exceed 100.
         *
         * @generated from field: double blackness = 3;
         */
        this.blackness = 0;
        /**
         * The color's alpha channel. Mandatory. Must be between 0 and 1,
         * inclusive.
         *
         * @generated from field: double alpha = 4;
         */
        this.alpha = 0;
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Value_HwbColor().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Value_HwbColor().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Value_HwbColor().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(Value_HwbColor, a, b);
    }
}
exports.Value_HwbColor = Value_HwbColor;
Value_HwbColor.runtime = protobuf_1.proto3;
Value_HwbColor.typeName = "sass.embedded_protocol.Value.HwbColor";
Value_HwbColor.fields = protobuf_1.proto3.util.newFieldList(() => [
    { no: 1, name: "hue", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 2, name: "whiteness", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "blackness", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 4, name: "alpha", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
]);
/**
 * A SassScript list value.
 *
 * @generated from message sass.embedded_protocol.Value.List
 */
class Value_List extends protobuf_1.Message {
    constructor(data) {
        super();
        /**
         * The type of separator for this list. Mandatory.
         *
         * @generated from field: sass.embedded_protocol.ListSeparator separator = 1;
         */
        this.separator = ListSeparator.COMMA;
        /**
         * Whether this list has square brackets. Mandatory.
         *
         * @generated from field: bool has_brackets = 2;
         */
        this.hasBrackets = false;
        /**
         * The elements of this list.
         *
         * @generated from field: repeated sass.embedded_protocol.Value contents = 3;
         */
        this.contents = [];
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Value_List().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Value_List().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Value_List().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(Value_List, a, b);
    }
}
exports.Value_List = Value_List;
Value_List.runtime = protobuf_1.proto3;
Value_List.typeName = "sass.embedded_protocol.Value.List";
Value_List.fields = protobuf_1.proto3.util.newFieldList(() => [
    { no: 1, name: "separator", kind: "enum", T: protobuf_1.proto3.getEnumType(ListSeparator) },
    { no: 2, name: "has_brackets", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "contents", kind: "message", T: Value, repeated: true },
]);
/**
 * A SassScript map value.
 *
 * @generated from message sass.embedded_protocol.Value.Map
 */
class Value_Map extends protobuf_1.Message {
    constructor(data) {
        super();
        /**
         * The entries in this map. The sending endpoint must guarantee that no two
         * entries have the same key.
         *
         * @generated from field: repeated sass.embedded_protocol.Value.Map.Entry entries = 1;
         */
        this.entries = [];
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Value_Map().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Value_Map().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Value_Map().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(Value_Map, a, b);
    }
}
exports.Value_Map = Value_Map;
Value_Map.runtime = protobuf_1.proto3;
Value_Map.typeName = "sass.embedded_protocol.Value.Map";
Value_Map.fields = protobuf_1.proto3.util.newFieldList(() => [
    { no: 1, name: "entries", kind: "message", T: Value_Map_Entry, repeated: true },
]);
/**
 * A single key/value pair in the map.
 *
 * @generated from message sass.embedded_protocol.Value.Map.Entry
 */
class Value_Map_Entry extends protobuf_1.Message {
    constructor(data) {
        super();
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Value_Map_Entry().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Value_Map_Entry().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Value_Map_Entry().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(Value_Map_Entry, a, b);
    }
}
exports.Value_Map_Entry = Value_Map_Entry;
Value_Map_Entry.runtime = protobuf_1.proto3;
Value_Map_Entry.typeName = "sass.embedded_protocol.Value.Map.Entry";
Value_Map_Entry.fields = protobuf_1.proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "message", T: Value },
    { no: 2, name: "value", kind: "message", T: Value },
]);
/**
 * A first-class function defined in the compiler. New `CompilerFunction`s may
 * only be created by the compiler, but the host may pass `CompilerFunction`s
 * back to the compiler as long as their IDs match IDs of functions received
 * by the host during that same compilation.
 *
 * @generated from message sass.embedded_protocol.Value.CompilerFunction
 */
class Value_CompilerFunction extends protobuf_1.Message {
    constructor(data) {
        super();
        /**
         * A unique ID for this function. The compiler is responsible for generating
         * this ID and ensuring it's unique across all functions passed to the host
         * for this compilation. Mandatory.
         *
         * @generated from field: uint32 id = 1;
         */
        this.id = 0;
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Value_CompilerFunction().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Value_CompilerFunction().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Value_CompilerFunction().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(Value_CompilerFunction, a, b);
    }
}
exports.Value_CompilerFunction = Value_CompilerFunction;
Value_CompilerFunction.runtime = protobuf_1.proto3;
Value_CompilerFunction.typeName = "sass.embedded_protocol.Value.CompilerFunction";
Value_CompilerFunction.fields = protobuf_1.proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
]);
/**
 * An anonymous custom function defined in the host. New `HostFunction`s may
 * only be created by the host, and `HostFunction`s may *never* be passed from
 * the compiler to the host. The compiler must instead pass a
 * `CompilerFunction` that wraps the `HostFunction`.
 *
 * @generated from message sass.embedded_protocol.Value.HostFunction
 */
class Value_HostFunction extends protobuf_1.Message {
    constructor(data) {
        super();
        /**
         * A unique ID for this function. The compiler must pass this ID as
         * `OutboundRequest.FunctionCallRequest.id` when invoking this function. The
         * host is responsible for generating this ID and ensuring it's unique
         * across all functions for *all* compilations. Mandatory.
         *
         * @generated from field: uint32 id = 1;
         */
        this.id = 0;
        /**
         * The signature for this function. Mandatory.
         *
         * If this isn't a valid Sass function signature that could appear after
         * `@function` in a Sass stylesheet (such as `mix($color1, $color2, $weight:
         * 50%)`), the compiler must treat it as though the function that returned
         * this `HostFunction` threw an error.
         *
         * > This ensures that the host doesn't need to be able to correctly parse
         * > the entire function declaration syntax.
         *
         * The compiler may not invoke the function by its name, since it's not
         * guaranteed to be globally unique. However, it may use the name to
         * generate the string representation of this function.
         *
         * @generated from field: string signature = 2;
         */
        this.signature = "";
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Value_HostFunction().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Value_HostFunction().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Value_HostFunction().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(Value_HostFunction, a, b);
    }
}
exports.Value_HostFunction = Value_HostFunction;
Value_HostFunction.runtime = protobuf_1.proto3;
Value_HostFunction.typeName = "sass.embedded_protocol.Value.HostFunction";
Value_HostFunction.fields = protobuf_1.proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "signature", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
/**
 * A first-class mixin defined in the compiler. New `CompilerMixin`s may
 * only be created by the compiler, but the host may pass `CompilerMixin`s
 * back to the compiler as long as their IDs match IDs of mixins received
 * by the host during that same compilation.
 *
 * @generated from message sass.embedded_protocol.Value.CompilerMixin
 */
class Value_CompilerMixin extends protobuf_1.Message {
    constructor(data) {
        super();
        /**
         * A unique ID for this mixin. The compiler is responsible for generating
         * this ID and ensuring it's unique across all mixins passed to the host
         * for this compilation. Mandatory.
         *
         * @generated from field: uint32 id = 1;
         */
        this.id = 0;
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Value_CompilerMixin().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Value_CompilerMixin().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Value_CompilerMixin().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(Value_CompilerMixin, a, b);
    }
}
exports.Value_CompilerMixin = Value_CompilerMixin;
Value_CompilerMixin.runtime = protobuf_1.proto3;
Value_CompilerMixin.typeName = "sass.embedded_protocol.Value.CompilerMixin";
Value_CompilerMixin.fields = protobuf_1.proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
]);
/**
 * A SassScript argument list value. This represents rest arguments passed to
 * a function's `$arg...` parameter. Unlike a normal `List`, an argument list
 * has an associated keywords map which tracks keyword arguments passed in
 * alongside positional arguments.
 *
 * For each `ArgumentList` in `FunctionCallRequest.arguments` (including those
 * nested within `List`s and `Map`s), the host must track whether its keyword
 * arguments were accessed by the user. If they were, it must add its
 * `ArgumentList.id` to `FunctionCallResponse.accessed_argument_lists`.
 *
 * The compiler must treat every `ArgumentList` whose `ArgumentList.id`
 * appears in `FunctionCallResponse.accessed_argument_lists` as though it had
 * been passed to `meta.keywords()`.
 *
 * @generated from message sass.embedded_protocol.Value.ArgumentList
 */
class Value_ArgumentList extends protobuf_1.Message {
    constructor(data) {
        super();
        /**
         * An ID for this argument list that's unique within the scope of a given
         * `FunctionCallRequest`.
         *
         * The special ID `0` is reserved for `ArgumentList`s created by the host,
         * and may not be used by the compiler. These `ArgumentList`s do not need to
         * have their IDs added to `FunctionCallResponse.accessed_argument_lists`,
         * and the compiler should treat them as though their keywords have always
         * been accessed.
         *
         * @generated from field: uint32 id = 1;
         */
        this.id = 0;
        /**
         * The type of separator for this list. The compiler must set this, but
         * the host may omit it for `ArgumentList`s that were originally created by
         * the compiler (that is, those with a non-0 ID).
         *
         * @generated from field: sass.embedded_protocol.ListSeparator separator = 2;
         */
        this.separator = ListSeparator.COMMA;
        /**
         * The argument list's positional contents. The compiler must set this, but
         * the host may omit it for `ArgumentList`s that were originally created by
         * the compiler (that is, those with a non-0 ID).
         *
         * @generated from field: repeated sass.embedded_protocol.Value contents = 3;
         */
        this.contents = [];
        /**
         * The argument list's keywords. The compiler must set this, but the host
         * may omit it for `ArgumentList`s that were originally created by the
         * compiler (that is, those with a non-0 ID).
         *
         * @generated from field: map<string, sass.embedded_protocol.Value> keywords = 4;
         */
        this.keywords = {};
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Value_ArgumentList().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Value_ArgumentList().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Value_ArgumentList().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(Value_ArgumentList, a, b);
    }
}
exports.Value_ArgumentList = Value_ArgumentList;
Value_ArgumentList.runtime = protobuf_1.proto3;
Value_ArgumentList.typeName = "sass.embedded_protocol.Value.ArgumentList";
Value_ArgumentList.fields = protobuf_1.proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "separator", kind: "enum", T: protobuf_1.proto3.getEnumType(ListSeparator) },
    { no: 3, name: "contents", kind: "message", T: Value, repeated: true },
    { no: 4, name: "keywords", kind: "map", K: 9 /* ScalarType.STRING */, V: { kind: "message", T: Value } },
]);
/**
 * A SassScript calculation value. The compiler must send fully [simplified]
 * calculations, meaning that simplifying it again will produce the same
 * calculation. The host is not required to simplify calculations.
 *
 * [simplified]: https://github.com/sass/sass/tree/main/spec/types/calculation.md#simplifying-a-calculation
 *
 * The compiler must simplify any calculations it receives from the host
 * before returning them from a function. If this simplification produces an
 * error, it should be treated as though the function call threw that error.
 * It should *not* be treated as a protocol error.
 *
 * @generated from message sass.embedded_protocol.Value.Calculation
 */
class Value_Calculation extends protobuf_1.Message {
    constructor(data) {
        super();
        /**
         * The calculation's name. Mandatory. The host may only set this to names
         * that the Sass specification uses to create calculations.
         *
         * @generated from field: string name = 1;
         */
        this.name = "";
        /**
         * The calculation's arguments. Mandatory. The host must use exactly the
         * number of arguments used by the Sass specification for calculations with
         * the given `name`.
         *
         * @generated from field: repeated sass.embedded_protocol.Value.Calculation.CalculationValue arguments = 2;
         */
        this.arguments = [];
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Value_Calculation().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Value_Calculation().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Value_Calculation().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(Value_Calculation, a, b);
    }
}
exports.Value_Calculation = Value_Calculation;
Value_Calculation.runtime = protobuf_1.proto3;
Value_Calculation.typeName = "sass.embedded_protocol.Value.Calculation";
Value_Calculation.fields = protobuf_1.proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "arguments", kind: "message", T: Value_Calculation_CalculationValue, repeated: true },
]);
/**
 * A single component of a calculation expression.
 *
 * @generated from message sass.embedded_protocol.Value.Calculation.CalculationValue
 */
class Value_Calculation_CalculationValue extends protobuf_1.Message {
    constructor(data) {
        super();
        /**
         * The value of the component. Mandatory.
         *
         * @generated from oneof sass.embedded_protocol.Value.Calculation.CalculationValue.value
         */
        this.value = { case: undefined };
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Value_Calculation_CalculationValue().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Value_Calculation_CalculationValue().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Value_Calculation_CalculationValue().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(Value_Calculation_CalculationValue, a, b);
    }
}
exports.Value_Calculation_CalculationValue = Value_Calculation_CalculationValue;
Value_Calculation_CalculationValue.runtime = protobuf_1.proto3;
Value_Calculation_CalculationValue.typeName = "sass.embedded_protocol.Value.Calculation.CalculationValue";
Value_Calculation_CalculationValue.fields = protobuf_1.proto3.util.newFieldList(() => [
    { no: 1, name: "number", kind: "message", T: Value_Number, oneof: "value" },
    { no: 2, name: "string", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "value" },
    { no: 3, name: "interpolation", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "value" },
    { no: 4, name: "operation", kind: "message", T: Value_Calculation_CalculationOperation, oneof: "value" },
    { no: 5, name: "calculation", kind: "message", T: Value_Calculation, oneof: "value" },
]);
/**
 * A binary operation that appears in a calculation.
 *
 * @generated from message sass.embedded_protocol.Value.Calculation.CalculationOperation
 */
class Value_Calculation_CalculationOperation extends protobuf_1.Message {
    constructor(data) {
        super();
        /**
         * The operator to perform.
         *
         * @generated from field: sass.embedded_protocol.CalculationOperator operator = 1;
         */
        this.operator = CalculationOperator.PLUS;
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Value_Calculation_CalculationOperation().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Value_Calculation_CalculationOperation().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Value_Calculation_CalculationOperation().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(Value_Calculation_CalculationOperation, a, b);
    }
}
exports.Value_Calculation_CalculationOperation = Value_Calculation_CalculationOperation;
Value_Calculation_CalculationOperation.runtime = protobuf_1.proto3;
Value_Calculation_CalculationOperation.typeName = "sass.embedded_protocol.Value.Calculation.CalculationOperation";
Value_Calculation_CalculationOperation.fields = protobuf_1.proto3.util.newFieldList(() => [
    { no: 1, name: "operator", kind: "enum", T: protobuf_1.proto3.getEnumType(CalculationOperator) },
    { no: 2, name: "left", kind: "message", T: Value_Calculation_CalculationValue },
    { no: 3, name: "right", kind: "message", T: Value_Calculation_CalculationValue },
]);
/**
 * The built-in Node.js Package Importer, which is a Package Importer that
 * resolves using the standards and conventions of the Node.js ecosystem. It
 * enables a `pkg:` URL scheme for usage with `@use` that directs an
 * implementation to resolve a URL within a dependency.
 *
 * @generated from message sass.embedded_protocol.NodePackageImporter
 */
class NodePackageImporter extends protobuf_1.Message {
    constructor(data) {
        super();
        /**
         * The absolute path to associate with the Node Package Importer, with
         * semantics identical to the [entryPointDirectory option] in the JavaScript
         * API.
         *
         * [entryPointDirectory option]: https://sass-lang.com/documentation/js-api/classes/NodePackageImporter.html#constructor
         *
         * @generated from field: string entry_point_directory = 1;
         */
        this.entryPointDirectory = "";
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new NodePackageImporter().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new NodePackageImporter().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new NodePackageImporter().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(NodePackageImporter, a, b);
    }
}
exports.NodePackageImporter = NodePackageImporter;
NodePackageImporter.runtime = protobuf_1.proto3;
NodePackageImporter.typeName = "sass.embedded_protocol.NodePackageImporter";
NodePackageImporter.fields = protobuf_1.proto3.util.newFieldList(() => [
    { no: 1, name: "entry_point_directory", kind: "scalar", T: 9 /* ScalarType.STRING */ },
]);
//# sourceMappingURL=embedded_sass_pb.js.map